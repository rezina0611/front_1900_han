리액트 라이프사이클
   - 페이지에 컴포넌트가 생성되고, 수정되고, 사라지는 순서를 의미한다.
   React에서 클래스 컴포넌트를 사용하면, 9개의 메소드를 통해 작업 흐름을 제어할 수 있다.

마운트
   - constructor : 새로운 컴포넌트를 생성할 때 마다 실행   
   - getDerivedStateFromProps : props를 state에 넣을 때 사용한다.   벌처메서드
   컴포넌트가 마운트될 때와 업데이트가 될 때 실행된다.
   - render : 준비해놓은 UI를 랜더링할 때 실행된다.
   - componentDidMount : 페이지에 컴포넌트가 나타난 직 후 실행된다.

업데이트
   - getDerivedStateFromProps
   - shouldComponentUpdate : true를 리턴 시 다음 라이프사이클 메소드가 계속 실행된다.
   만약 false를 리턴할 경우 작업이 중지된다.
   - getSnapshotBeforeUpdate : 컴포넌트 업데이트 직전의 값을 snapshot에 저장한다.
   또한 업데이트 직전에 실행된다.
   - componentDidUpdate : 컴포넌트 업데이트 직후 실행된다.

언마운트
   - componentWillUnmount : 컴포넌트가 사라지기 직전에 실행되는 메서드

---------------------------------------------------------------------------

참조 투명성
	- 입력받아서 입력을 받은 그대로 출력하는 함수를 참조 투명하다고 하며 순수 함수(Pure Function)이라고 한다. 하지만 입력 받았을때 다른 결과로 출력하거나 외부 함수에 영향을 끼치는 함수를 참조 불투명하다고 한다. 이렇게 순수 함수가 아닌 함수에서 Side-Effect가 발생한다.

	- 리액트는 모든 함수를 순수 함수로 유지할 것을 권장하고 있으며, 이로인해 컴포넌트의 재사용이 좋아지고 오류검사 및 테스트도 좋아진다.

Side-Effect
	- 함수 내 특정 동작이 함수 외부에 영향을 끼쳐, 프로그램의 동작을 이해하기 어렵게 만드는 행위
a) setTimeOut, setInerval
b) 서버와의 통신(fetct, axios)
c) 그외 비동기 함수


3. useEffect
    - Side-Effect를 따로 관리하여 컴포넌트가 최대한 순수 함수를 유지할 수 있도록 도와주는 함수
    - useEffect()는 랜더링이 모두 끝난 다음에 실행된다.
    
    가용 범위는?
    
    - 랜더링 될 때 마다 실행
        - useEffect( () ⇒ {})
    - 최초 랜더링(마운트)할 때만 실행
        - useEffect( () ⇒ {} , [])         => [] 의존성 배열
        - 즉 비워 놓으면 최초 한번만 아예 전달한게 없으니 평생 리랜더링 될 수 없다.
        - 즉 === componentDidMount()와 똑같다.
    - 특정 컴포넌트 변경 시 실행
        - useEffect( () ⇒ {} , [state])


memoization
	- 함수형 컴포넌트에서 다른 변화 때문에 연산이 되는 불필요한 연산을 안하게 하기 위해 사용한다.

useMemo란?
	-useMemo는 메모리에 있는 캐시를 사용하는 함수이다.
	-캐시에 있는 것을 쓴다는 것은 최초에 마운트를 할때 연산결과를 캐시에 담아놓고 리랜더링이 있을때 캐시와 결과를 비교하고, 내가 원하는 값의 변화를 줄때만 연산을 수행한다.
이것을 memoization이라고 한다.


===============================

react style
[components]
[utils]
   - arrayheler.js
   - parseheler.js
[consts]
   - key.js (상수, 문자열)
[styles]
   - theme.js
   - globalStyle.js
   - common.js
   ...
[pages]
   [Home]
      [Hooks]
      [Components]
      -home.js
[routes]
[hooks]
... etc

study 폴더안에 설치
yarn add styled-components @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome styled-reset @fortawesome/fontawesome-svg-core react-router-dom



rsc 탭


Context API란?
   - 리액의 내장 API(16버전 이상) 중 하나로 Props를 넘겨주지 않고도 컴포넌트 트리 전체에 
   데이터를 처리할 수 있도록 제공해주는 API

Props의 드릴링
   - A.jsx ~ Z.jsx까지 있다고 가정할 때 부모 A컴포넌트부터 최하위 Z컴포넌트까지
   Props를 보내는 과정을 Props의 드릴링이라고 한다.

Context API는 언제 사용할까?
   - 변화가 없는 것. 즉 다크모드 화이트모드 등 값이 선언되어 있는 상태로 변화가 없는
   상태의 변수를 지정할 때 사용한다.
   - Context는 변화를 시켜주는 API가 아니다.
   - 변화를 주면 안되지만 혹시나 변화를 생길것을 대비하여 만들어져 있다.

Context의 단점
   - Provider 컴포넌트는 value Props를 받아서 하위 컴포넌트에게 전달한다
   - value가 업데이트 되었을 때 Context로 감싸진   모든 컴포넌트가 리랜더링 된다.



라우터
Routing
   - 클라이언트가 요청한 URL을 분석하여 알맞는 페이지로 응답하는 것
   여러 페이지로 구성된 웹 애플리케이션을 만들 때 사용한다.

MPA(Multiple Page Application)
   - 여러 개 페이지로 이루어진 애플리케이션이다.
   클라이언트가 서버에 요청을 보내면 서버에서 랜더링 한 뒤 클라이언트에 응답해주는 SSR(Server Side Rendering)
   방식으로 사용한다. 매번 이동 시 새로고침 되기 때문에 깜빡임 현상이 발생한다.

SPA(Single Page Application)
   - 하나의 페이지로 이루어진 애플리케이션이다.
   페이지를 딱 한개만 받아온 뒤 데이터만 받아와서 화면을 업데이트 하는 것이다.
   링크를 클릭하면 경로가 바뀌며 히스토리에도 남기 때문에 클라이언트 입장에서는 여러 페이지가 존재하는 것처럼 보인다.
   하지만 경로가 바뀌어도 주소창의 경로만 변경되고 기존 페이지는 유지하며, 다른 페이지의 데이터를 보여주게 된다.
   즉 CSR(Client Side Rendering)방식을 사용한다.
   페이지 이동(불러오기)에 대한 속도가 굉장히 빠르다.
   그러나 비어있는 HTML 문서가 먼저 도착한 뒤 JS 연산 및 데이터 요청이 시작되므로 
   데이터 분석과 검색 엔진에 취약하다.

CSR 장점
   - 페이지에 필요한 리소스를 전부 사전에 불러와 데이터를 캐싱하고 있다가 현재 URL에 맞는 페이지를 보여주기 때문에
   초기 랜더링 이후 속도가 빠르다.
CSR 단점
   - 모든 리소스를 불러와야 하기 때문에 초기 페이지 로딩이 SSR보다 느리다.
   - SEO(검색 엔진 최적화)에 불리하다
SSR 장점
   - SEO에 유리하다. 서버에서 완성된 페이지를 전달해주기 때문에 검색 엔진이 수집하기 용이하며,
   서버에서 랜더링을 부담하기 때문에 사용자의 하드웨어에 의존하지 않는다.
SSR 단점
   - 서버에 부담이 된다. 생산 비용이 증가한다.
   - SSR을 위한 코드 작성이 필요하다.


검색 엔진 최적화(SEO, Search Engine Optimization)

URL 파라미터와 쿼리스트링
- URL 파라미터(useParams())
    - URL 경로로 작성하여 값을 전달하는 방식
- 쿼리 스트링(useSearchParams())
    - URL 경로 뒤에 ?로 시작하여 key=value 형식으로 값을 전달하거나
    - 값이 여러개 일 경우 &를 연결하여 값을 전달하는 방식

프로토콜   도메인  포트
localhost:3000/

npx json-server ./members.js --port 4000

yarn add react-hook-form   
react-hook-form@7.69.0



리액트 훅 폼
   - register : input 요소를 React hook form과 연결해 검증 규칙을 적용할 수 있게 하는 메소드
   - handleSubmit : form을 submit했을 때 실행할 함수.
   - formState : form state에 관한 정보를 담고 있는 객체
   - errors : input 값들의 에러 정보를 가지고 있는 객체
   - getValues : input 값을 가져올 수 있는 함수

모드
   - `useForm({ mode: "onChange" })` 
   - mode를 설정함으로써 해당 모드의 register 안 검증 로직이 동작하는 규칙을 정할 수 있다.
   
   - onChange : input 값이 바뀔 때마다 검증 로직이 동작한다.
   - onBlur : 포커스 상태를 잃어 버릴 때 동작한다.
   - onSubmit : 제출 함수가 실행될 때 동작한다.
   - onTouched : 첫 번째 blur 이벤트에서 동작한다. 그 후에는 모든 change 이벤트에서 동작한다.
   - all : blur 및 change 이벤트에서 동작한다.


정규식 표현법
   정규 표현식의 용어들정규 표현식에서 사용되는 기호를 Meta문자라고 표현한다.
   표현식에서 내부적으로 특정 의미를 가지는 문자를 말하며 간단하게 정리하면 아래의 표와 같다.

^x : 문자열의 시작을 표현하며 x 문자로 시작됨을 의미한다.
x$ : 문자열의 종료를 표현하며 x 문자로 종료됨을 의미한다.
.x : 임의의 한 문자의 자리수를 표현하며 문자열이 x 로 끝난다는 것을 의미한다.
x+ : 반복을 표현하며 x 문자가 한번 이상 반복됨을 의미한다.
x? : 존재여부를 표현하며 x 문자가 존재할 수도, 존재하지 않을 수도 있음을 의미한다.
x* : 반복여부를 표현하며 x 문자가 0번 또는 그 이상 반복됨을 의미한다.
x|y : or 를 표현하며 x 또는 y 문자가 존재함을 의미한다.
(x) : 그룹을 표현하며 x 를 그룹으로 처리함을 의미한다.
(x)(y) : 그룹들의 집합을 표현하며 앞에서 부터 순서대로 번호를 부여하여 관리하고 x, y 는 각 그룹의 데이터로 관리된다.
(x)(?:y) : 그룹들의 집합에 대한 예외를 표현하며 그룹 집합으로 관리되지 않음을 의미한다. 
x{n} : 반복을 표현하며 x 문자가 n번 반복됨을 의미한다.
x{n,} : 반복을 표현하며 x 문자가 n번 이상 반복됨을 의미한다.
x{n,m} : 반복을 표현하며 x 문자가 최소 n번 이상 최대 m 번 이하로 반복됨을 의미한다.

'[]' 는 내부에 지정된 문자열의 범위 중에서 한 문자만을 선택하다는 특수한 의미를 가진다. 
그리고 내부에서 Meta문자를 사용하면 다른 의미를 가지고 동작할 수 있으므로 잘 확인하고 사용해야 한다. 
좀 더 특별한 용도로 사용되는 것들은 아래의 표와 같다. 

[xy] : 문자 선택을 표현하며 x 와 y 중에 하나를 의미한다.
[^xy] : not 을 표현하며  x 및 y 를 제외한 문자를 의미한다.
[x-z] : range를 표현하며 x ~ z 사이의 문자를 의미한다. 
\^ : escape 를 표현하며 ^ 를 문자로 사용함을 의미한다.
\b : word boundary를 표현하며 문자와 공백사이의 문자를 의미한다.
\B : non word boundary를 표현하며 문자와 공백사이가 아닌 문자를 의미한다.
\d : digit 를 표현하며 숫자를 의미한다. 
\D : non digit 를 표현하며 숫자가 아닌 것을 의미한다. 
\s : space 를 표현하며 공백 문자를 의미한다. 
\S : non space를 표현하며 공백 문자가 아닌 것을 의미한다.
\t : tab 을 표현하며 탭 문자를 의미한다.
\v : vertical tab을 표현하며 수직 탭(?) 문자를 의미한다.
\w : word 를 표현하며 알파벳 + 숫자 + _ 중의 한 문자임을 의미한다. 
\W : non word를 표현하며 알파벳 + 숫자 + _ 가 아닌 문자를 의미한다. 


npx json-server ./members.js --port 4000

yarn add @tanstack/react-query

yarn add zustand

C 추가 R 조회 U 수정 D 삭제
추가: POST
수정: PUT


리액트 쿼리의 주요기능
- 데이터 가져오기 및 캐싱
- 동일요청의 중복 제거
- 신선한 데이터 유지
- 무한 스크롤, 페이지네이션 등의 성능 최적화
- 네트워크 재연결, 요청 실패 등의 자동갱신

리액트 쿼리 주요 동작 설명


https://github.com/dev-tpghks23/template-reactapp/tree/main

front폴더에 오른쪽마우스  추가옵션표시
open git Bash here
**“Open Git Bash Here”**는
👉 현재 폴더 위치에서 바로 Git Bash 터미널을 여는 기능입니다.

git clone 
https://github.com/dev-tpghks23/template-reactapp.git



Zustand
   - 전역 상태를 간단하고 효율적으로 관리할 수 있게 도와주는 상태 관리 라이브러리
   메모리 기반 상태 관리를 제공하며 상태가 브라우저 메모리(RAM)에 저장되어 
   앱이 살아 있는 동안만 유지된다. 상태 유지를 위해 주로 로컬스토리지와 함께 사용된다.
   - https://zustand.docs.pmnd.rs/getting-started/introduction
   
Store
   - 컴포넌트간의 데이터를 공유하기 위해선 상위 컴포넌트를 거쳐야 하는 Props Drilling을 없애고
   컴포넌트간의 Store를 사이에 두어 여러 컴포넌트가 같은 데이터를 쉽게 보고 
   수정할 수 있는 중앙 저장소를 의미한다.
   
Zustand의 주요 함수
   1. create
   - State와 Action을 통합 정의할 수 있고, 반환되는 훅으로 상태 접근과 액션 호출을
   동시에 처리할 수 있다. 또한 필요한 상태만 선택적으로 구독(subscribe)해 
   불필요한 리렌더링을 방지할 수 있습니다
   
   2. set
   - 상태를 업데이트하는 함수로, create 함수 내부에서 사용됩니다. 기존 상태를 
   불변성을 유지하면서 부분적으로 변경할 수 있으며, 함수 형태로도 값을 갱신할 수 있어 
   복잡한 상태 계산도 가능합니다.

   3. persist
   - Zustand 상태를 브라우저의 로컬 스토리지(localStorage)나 세션 스토리지(sessionStorage)에
   자동으로 저장하고 불러올 수 있게 해주는 미들웨어입니다. 페이지를 새로고침해도 상태가
   유지되므로, 로그인 정보나 테마 설정 등 지속적인 상태 관리에 유용합니다.



타입스크립트란?
   - 자바스크립에 타입을 부여하여 확장한 언어이다.
   - 마이크로소프트(MS)에 의해 개발/관리되고 있는 오픈 소스 프로그래밍 언어이다.
   - ES5의 Superset이므로 기존 자바스크립트(ES5) 문법을 그대로 사용할 수 있으며,
   ES6의 새로운 기능을 사용하기 위해 Babel과 같은 별도의 트랜스파일러(Transpiler)를 사용하지 않아도
   새로운 기능을 자바스크립트 엔진(웹 브라우저 및 Node.js)에서 실행할 수 있다.

타입스크립트의 장점?
   - 자바스크립트의 동적 바인딩이 아닌 정적 바인딩으로 정적 타입을 지원한다.
   - 자바스크립트 코드의 문법 상 어떠한 문제가 없더라도 변수나 반환값의 타입을 사전으로 지정하지 않는
   동적 타이핑(Dynamic Typing)에 의한 오류를 해결하기 위한 정적 타이핑(Static Typing)을
   제공하여 오류를 포착하고 가독성을 높이며, 오류를 예측할 수 있게 디버깅을 쉽게 할 수 있다.

