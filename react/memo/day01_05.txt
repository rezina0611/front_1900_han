리액트 라이프사이클
   - 페이지에 컴포넌트가 생성되고, 수정되고, 사라지는 순서를 의미한다.
   React에서 클래스 컴포넌트를 사용하면, 9개의 메소드를 통해 작업 흐름을 제어할 수 있다.

마운트
   - constructor : 새로운 컴포넌트를 생성할 때 마다 실행   
   - getDerivedStateFromProps : props를 state에 넣을 때 사용한다.   벌처메서드
   컴포넌트가 마운트될 때와 업데이트가 될 때 실행된다.
   - render : 준비해놓은 UI를 랜더링할 때 실행된다.
   - componentDidMount : 페이지에 컴포넌트가 나타난 직 후 실행된다.

업데이트
   - getDerivedStateFromProps
   - shouldComponentUpdate : true를 리턴 시 다음 라이프사이클 메소드가 계속 실행된다.
   만약 false를 리턴할 경우 작업이 중지된다.
   - getSnapshotBeforeUpdate : 컴포넌트 업데이트 직전의 값을 snapshot에 저장한다.
   또한 업데이트 직전에 실행된다.
   - componentDidUpdate : 컴포넌트 업데이트 직후 실행된다.

언마운트
   - componentWillUnmount : 컴포넌트가 사라지기 직전에 실행되는 메서드

---------------------------------------------------------------------------

참조 투명성
	- 입력받아서 입력을 받은 그대로 출력하는 함수를 참조 투명하다고 하며 순수 함수(Pure Function)이라고 한다. 하지만 입력 받았을때 다른 결과로 출력하거나 외부 함수에 영향을 끼치는 함수를 참조 불투명하다고 한다. 이렇게 순수 함수가 아닌 함수에서 Side-Effect가 발생한다.

	- 리액트는 모든 함수를 순수 함수로 유지할 것을 권장하고 있으며, 이로인해 컴포넌트의 재사용이 좋아지고 오류검사 및 테스트도 좋아진다.

Side-Effect
	- 함수 내 특정 동작이 함수 외부에 영향을 끼쳐, 프로그램의 동작을 이해하기 어렵게 만드는 행위
a) setTimeOut, setInerval
b) 서버와의 통신(fetct, axios)
c) 그외 비동기 함수


3. useEffect
    - Side-Effect를 따로 관리하여 컴포넌트가 최대한 순수 함수를 유지할 수 있도록 도와주는 함수
    - useEffect()는 랜더링이 모두 끝난 다음에 실행된다.
    
    가용 범위는?
    
    - 랜더링 될 때 마다 실행
        - useEffect( () ⇒ {})
    - 최초 랜더링(마운트)할 때만 실행
        - useEffect( () ⇒ {} , [])         => [] 의존성 배열
        - 즉 비워 놓으면 최초 한번만 아예 전달한게 없으니 평생 리랜더링 될 수 없다.
        - 즉 === componentDidMount()와 똑같다.
    - 특정 컴포넌트 변경 시 실행
        - useEffect( () ⇒ {} , [state])


memoization
	- 함수형 컴포넌트에서 다른 변화 때문에 연산이 되는 불필요한 연산을 안하게 하기 위해 사용한다.

useMemo란?
	-useMemo는 메모리에 있는 캐시를 사용하는 함수이다.
	-캐시에 있는 것을 쓴다는 것은 최초에 마운트를 할때 연산결과를 캐시에 담아놓고 리랜더링이 있을때 캐시와 결과를 비교하고, 내가 원하는 값의 변화를 줄때만 연산을 수행한다.
이것을 memoization이라고 한다.


===============================

react style
[components]
[utils]
   - arrayheler.js
   - parseheler.js
[consts]
   - key.js (상수, 문자열)
[styles]
   - theme.js
   - globalStyle.js
   - common.js
   ...
[pages]
   [Home]
      [Hooks]
      [Components]
      -home.js
[routes]
[hooks]
... etc

study 폴더안에 설치
yarn add styled-components @fortawesome/free-solid-svg-icons @fortawesome/react-fontawesome styled-reset @fortawesome/fontawesome-svg-core react-router-dom



rsc 탭


Context API란?
   - 리액의 내장 API(16버전 이상) 중 하나로 Props를 넘겨주지 않고도 컴포넌트 트리 전체에 
   데이터를 처리할 수 있도록 제공해주는 API

Props의 드릴링
   - A.jsx ~ Z.jsx까지 있다고 가정할 때 부모 A컴포넌트부터 최하위 Z컴포넌트까지
   Props를 보내는 과정을 Props의 드릴링이라고 한다.

Context API는 언제 사용할까?
   - 변화가 없는 것. 즉 다크모드 화이트모드 등 값이 선언되어 있는 상태로 변화가 없는
   상태의 변수를 지정할 때 사용한다.
   - Context는 변화를 시켜주는 API가 아니다.
   - 변화를 주면 안되지만 혹시나 변화를 생길것을 대비하여 만들어져 있다.

Context의 단점
   - Provider 컴포넌트는 value Props를 받아서 하위 컴포넌트에게 전달한다
   - value가 업데이트 되었을 때 Context로 감싸진   모든 컴포넌트가 리랜더링 된다.





